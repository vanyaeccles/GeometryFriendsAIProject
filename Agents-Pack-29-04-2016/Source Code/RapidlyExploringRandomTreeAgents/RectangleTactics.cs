// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
namespace GeometryFriendsAgents
{
	public class RectangleTactics : Tactics
	{
        private static int radius = 48;
        private static float min = 48;
        private static float max = 144;
        private static int MINSIZE = 48;
        private static int MAXSIZE = 192;
        private static int NORMALSIZE = 96;

		public RectangleTactics ()
		{
		}

        public override CircleNode apply(CircleNode Xinit, InfoDomain _domain, Graph graph) { return null; }

		public override RectangleNode apply (RectangleNode Xinit, InfoDomain _domain, Graph graph)
		{
            bool newState = false;
            RectangleActions rAction = new RectangleActions();
            int action = 0;
            State s = null;


            while (!newState)
            {
                if (Xinit.allActionsBusy())
                {
                    graph.NonBusyNodes.Remove(Xinit);
                    return null;
                }
                    
                action = rAction.getRandomAction();
                switch (action)
                {
                    case 0: //MOVE_LEFT
                        if (!Xinit._busyActions[0])
                        {
                            float[] newcoordinates = new float[4];
                            newcoordinates[0] = Xinit.getState().getPosX() - 32;
                            newcoordinates[1] = Xinit.getState().getPosY();
                            newcoordinates[2] = 0;  // 0 means going left
                            newcoordinates[3] = Xinit.getState().getVelocityY();
                            float[] gapInfo;

                            s = new State(newcoordinates[2], newcoordinates[3], newcoordinates[0], newcoordinates[1], 0, null, Xinit.getState().getAllCaughtCollectibles());
                            s.setSizeOfAgent(Xinit.getState().getSizeOfAgent());
                            s.point.Size = s.getSizeOfAgent();

                            int halfwidth = getWidth(s.getSizeOfAgent()) / 2;
                            int halfheight = s.getSizeOfAgent() / 2;

                            if (s.getPosX() + MINSIZE/2 <= Xinit.getState().CurrentPlatform.minWidth())
                            {
                                if ((!Xinit.getState().SpecialMoveL) && ((gapInfo = _domain.AllObstacles.isThereAGap(s, Xinit.getState().CurrentPlatform, min, max)) != null))
                                {
                                    //when it's gap it just needs to keep on going, but for the planning sake
                                    //we moved it's position to next platform's begining
                                    s.setPosX(s.getPosX() - gapInfo[0] - halfwidth);
                                    s.point.x = s.getPosX();
                                    s.CurrentPlatform = _domain.AllObstacles.getNextPlatform(s);
                                    Xinit.getState().SpecialMoveL = true;
                                    s.setPosX(s.CurrentPlatform.maxWidth() - halfwidth);
                                    s.setPosY(s.CurrentPlatform.maxHeight() - halfheight);
                                    s.point.Size = s.getSizeOfAgent();
                                    s.point.x = s.getPosX();
                                }
                                else
                                {
                                    if (Xinit.getState().SpecialMoveL)
                                    {
                                        gapInfo = gapInfo = _domain.AllObstacles.isThereAGap(s, Xinit.getState().CurrentPlatform, min, max);
                                        int gapsize = (int) gapInfo[3];
                                        if (gapsize <= NORMALSIZE)
                                        {
                                            s.setSizeOfAgent(getHeight(gapsize - 16));
                                            if (gapsize < MINSIZE)
                                                s.setSizeOfAgent(MAXSIZE);
                                        }
                                        else
                                            s.setSizeOfAgent(NORMALSIZE);

                                        s.CurrentPlatform = _domain.AllObstacles.getNextPlatformRange(s, NORMALSIZE);
                                        halfwidth = getWidth(s.getSizeOfAgent()) / 2;
                                        halfheight = s.getSizeOfAgent() / 2;
                                        s.setPosY(s.CurrentPlatform.maxHeight() - halfheight);
                                        s.point.y = Math.Min((Xinit.getState().CurrentPlatform.maxHeight() + NORMALSIZE), s.getPosY());
                                        s.point.x = Xinit.getState().CurrentPlatform.minWidth() - gapsize/2;
                                        s.setPosX(s.point.x);
                                        s.point.Size = s.getSizeOfAgent();
                                        s.point.FallGap = true;
                                    }
                                    else
                                    {
                                        s.point.x = Xinit.getState().CurrentPlatform.minWidth() - halfwidth;
                                        s.setPosX(s.point.x);
                                        s.setSizeOfAgent(possibleHeight(s, _domain));
                                        halfwidth = getWidth(s.getSizeOfAgent()) / 2;
                                        halfheight = s.getSizeOfAgent() / 2;
                                        s.setPosY(Xinit.getState().CurrentPlatform.maxHeight() - halfheight); //so distanceForMomentum is correct
                                        s.CurrentPlatform = Xinit.getState().CurrentPlatform;
                                        int distance = distanceForMomentum(s, _domain);
                                        s.point.DistanceMomentum = distance;
                                        s.CurrentPlatform = _domain.AllObstacles.getNextPlatformRange(s, distance);
                                        s.point.DistancePlatform = (int)Math.Max(0, Xinit.getState().CurrentPlatform.minWidth() - s.CurrentPlatform.maxWidth());
                                        s.setPosY(s.CurrentPlatform.maxHeight() - halfheight);
                                        s.point.y = Math.Min((Xinit.getState().CurrentPlatform.maxHeight() + NORMALSIZE), s.getPosY());
                                        s.point.x = Math.Min((Xinit.getState().CurrentPlatform.minWidth() - halfwidth), (s.CurrentPlatform.maxWidth() - halfwidth));
                                        s.setPosX(s.point.x);
                                        s.point.Size = s.getSizeOfAgent();
                                        s.point.Fall = true;
                                    }


                                    if (s.getSizeOfAgent() != Xinit.getState().getSizeOfAgent())
                                        s.point.Morph = true;
                                    Xinit.setActionBusy(0);
                                }
                            }
                            else
                            {
                                Xinit.setActionBusy(0);
                                s.CurrentPlatform = Xinit.getState().CurrentPlatform;
                            }

                            this.caughtCollectible(Xinit.getState(), s);
                            s.point.numberOfCollectibles = s.numberOfCollectibles();
                            if (!this.contains(s, graph))
                                newState = true;
                        }
                        break;
                    case 1: //MOVE_RIGHT
                        if (!Xinit._busyActions[1])
                        {
                            float[] newcoordinates = new float[4];
                            newcoordinates[0] = Xinit.getState().getPosX() + 32;
                            newcoordinates[1] = Xinit.getState().getPosY();
                            newcoordinates[2] = 1;  // 1 means going right
                            newcoordinates[3] = Xinit.getState().getVelocityY();
                            float[] gapInfo;

                            s = new State(newcoordinates[2], newcoordinates[3], newcoordinates[0], newcoordinates[1], 1, null, Xinit.getState().getAllCaughtCollectibles());
                            s.setSizeOfAgent(Xinit.getState().getSizeOfAgent());
                            s.point.Size = s.getSizeOfAgent();

                            int halfwidth = getWidth(s.getSizeOfAgent()) / 2;
                            int halfheight = s.getSizeOfAgent() / 2;

                            if (s.getPosX() - MINSIZE/2 >= Xinit.getState().CurrentPlatform.maxWidth())
                            {
                                if ((!Xinit.getState().SpecialMoveR) && ((gapInfo = _domain.AllObstacles.isThereAGap(s, Xinit.getState().CurrentPlatform, min, max)) != null))
                                {
                                    //when it's gap it just needs to keep on going, but for the planning sake
                                    //we moved it's position to next platform's begining
                                    s.setPosX(s.getPosX() + gapInfo[0] + halfwidth);
                                    s.point.x = s.getPosX();
                                    s.CurrentPlatform = _domain.AllObstacles.getNextPlatform(s);
                                    Xinit.getState().SpecialMoveR = true;
                                    s.setPosX(s.CurrentPlatform.minWidth() + halfwidth);
                                    s.setPosY(s.CurrentPlatform.maxHeight() - halfheight);
                                    s.point.y = s.getPosY();
                                    s.point.x = s.getPosX();
                                }
                                else
                                {
                                    if (Xinit.getState().SpecialMoveR)
                                    {
                                        gapInfo = _domain.AllObstacles.isThereAGap(s, Xinit.getState().CurrentPlatform, min, max);
                                        int gapsize = (int) gapInfo[3];
                                        if (gapsize <= NORMALSIZE)
                                        {
                                            s.setSizeOfAgent(getHeight(gapsize - 16));
                                            if (gapsize < MINSIZE)
                                                s.setSizeOfAgent(MAXSIZE);
                                        }
                                        else
                                            s.setSizeOfAgent(NORMALSIZE);
                                        s.CurrentPlatform = _domain.AllObstacles.getNextPlatformRange(s, NORMALSIZE);
                                        halfwidth = getWidth(s.getSizeOfAgent()) / 2;
                                        halfheight = s.getSizeOfAgent() / 2;
                                        s.setPosY(s.CurrentPlatform.maxHeight() - halfheight);
                                        s.point.y = Math.Min((Xinit.getState().CurrentPlatform.maxHeight() + NORMALSIZE), s.getPosY());
                                        s.point.x = Xinit.getState().CurrentPlatform.maxWidth() + gapsize/2;
                                        s.setPosX(s.point.x);
                                        s.point.Size = s.getSizeOfAgent();
                                        s.point.FallGap = true;
                                    }
                                    else
                                    {
                                        s.point.x = Xinit.getState().CurrentPlatform.maxWidth() + halfwidth;
                                        s.setPosX(s.point.x);
                                        s.setSizeOfAgent(possibleHeight(s, _domain));
                                        halfwidth = getWidth(s.getSizeOfAgent()) / 2;
                                        halfheight = s.getSizeOfAgent() / 2;
                                        s.point.x = Xinit.getState().CurrentPlatform.maxWidth() + halfwidth;
                                        s.setPosX(s.point.x);
                                        s.setPosY(Xinit.getState().CurrentPlatform.maxHeight() - halfheight);
                                        s.CurrentPlatform = Xinit.getState().CurrentPlatform;
                                        int distance = distanceForMomentum(s, _domain);
                                        s.point.DistanceMomentum = distance;
                                        s.CurrentPlatform = _domain.AllObstacles.getNextPlatformRange(s, distance);
                                        s.point.DistancePlatform = (int) Math.Max (0, s.CurrentPlatform.minWidth() - Xinit.getState().CurrentPlatform.maxWidth());
                                        s.setPosY(s.CurrentPlatform.maxHeight() - halfheight);
                                        s.point.y = Math.Min((Xinit.getState().CurrentPlatform.maxHeight() + NORMALSIZE),s.getPosY());
                                        s.point.x = Math.Max((Xinit.getState().CurrentPlatform.maxWidth() + halfwidth), (s.CurrentPlatform.minWidth() + halfwidth));
                                        s.setPosX(s.point.x);
                                        s.point.Size = s.getSizeOfAgent();
                                        s.point.Fall = true;
                                    }

                                    if (s.getSizeOfAgent() != Xinit.getState().getSizeOfAgent())
                                        s.point.Morph = true;
                                    Xinit.setActionBusy(1);
                                }
                            }
                            else
                            {
                                Xinit.setActionBusy(1);
                                s.CurrentPlatform = Xinit.getState().CurrentPlatform;
                            }


                            this.caughtCollectible(Xinit.getState(),s);
                            s.point.numberOfCollectibles = s.numberOfCollectibles();
                            if (!this.contains(s, graph))
                                newState = true;
                        }
                        break;
                    case 2: //MORPH_UP
                        if (!Xinit._busyActions[2])
                        {
							float[] newcoordinates = new float[4];
							newcoordinates[0] = Xinit.getState().getPosX();
							newcoordinates[1] = Xinit.getState().getPosY() + Xinit.getState().getSizeOfAgent()/2 - MAXSIZE;
							newcoordinates[2] = Xinit.getState().getVelocityX();  
							newcoordinates[3] = Xinit.getState().getVelocityY();
								
							s = new State(newcoordinates[2], newcoordinates[3], newcoordinates[0], newcoordinates[1], 2, null, Xinit.getState().getAllCaughtCollectibles());
                            s.setSizeOfAgent(Xinit.getState().getSizeOfAgent());
	
							Xinit.setActionBusy(2);
							s.CurrentPlatform = Xinit.getState().CurrentPlatform;
								
							this.caughtCollectible(Xinit.getState(), s);
							s.setPosY(Xinit.getState().getPosY());
                            s.point.y = s.getPosY(); //ok?
                            if (Xinit.getState().sizeOfCaughtCollectible() < s.sizeOfCaughtCollectible())
                            {
                                s.point.DiamondAbove = true;
                                if (Xinit.getState().getAction() == 0)
                                {
                                    s.point.x -= 32;
                                    s.point.x -= radius;
                                }
                                else if (Xinit.getState().getAction() == 1)
                                {
                                    s.point.x += 32;
                                    s.point.x += radius;
                                }
                            }
                            else
                            {
                                continue;
                            }

                            s.point.numberOfCollectibles = s.numberOfCollectibles();
							if (!this.contains(s, graph))
								newState = true;
                        }
                        break;
                    case 3: //MORPH_DOWN
                        if (!Xinit._busyActions[3])
                        {
                            float[] newcoordinates = new float[4];
                            if (!Xinit._busyMorphLeft)
                            {
                                newcoordinates[2] = 0;
                                Xinit._busyMorphLeft = true;
                            } 
                            else if (!Xinit._busyMorphRight)
                            {
                                newcoordinates[2] = 1;
                                Xinit._busyMorphRight = true;
                            }

                            newcoordinates[3] = Xinit.getState().getVelocityY();
                            if (newcoordinates[2] == 0)
                                newcoordinates[0] = Xinit.getState().getPosX() - 32;
                            else if (newcoordinates[2] == 1)
                                newcoordinates[0] = Xinit.getState().getPosX() + 32;
                            newcoordinates[1] = Xinit.getState().getPosY() + Xinit.getState().getSizeOfAgent()/2 - MINSIZE/2;
                            //float[] gapInfo;

                            s = new State(newcoordinates[2], newcoordinates[3], newcoordinates[0], newcoordinates[1], 3, null, Xinit.getState().getAllCaughtCollectibles());
                            s.setSizeOfAgent(MINSIZE);
                            s.point.Size = s.getSizeOfAgent();
            
                            s.CurrentPlatform = Xinit.getState().CurrentPlatform;

                            s.point.Morph = true;
                            this.caughtCollectible(Xinit.getState(), s);

                            s.point.numberOfCollectibles = s.numberOfCollectibles();
                            if (Xinit._busyMorphLeft && Xinit._busyMorphRight)
                                Xinit.setActionBusy(3);
                            if (!this.contains(s, graph)) //TODO equals ter em conta o size
                                newState = true;
                        }
                        break;
                    case 4: //TILT
                        if (!Xinit._busyActions[4])
                        {
                            int halfwidth = getWidth(Xinit.getState().getSizeOfAgent()) / 2;
                            float[] newcoordinates = new float[4];
                            if (!Xinit._busyTiltLeft)
                            {
                                Xinit._busyTiltLeft = true;
                                newcoordinates[2] = 0;
                                newcoordinates[0] = Xinit.getState().getPosX() - 32 - halfwidth;
                            }
                            else if (!Xinit._busyTiltRight)
                            {
                                Xinit._busyTiltRight = true;
                                newcoordinates[2] = 1;
                                newcoordinates[0] = Xinit.getState().getPosX() + 32 + halfwidth;
                            }
                            newcoordinates[3] = Xinit.getState().getVelocityY();
                            newcoordinates[1] = Xinit.getState().getPosY() - 96;

                            s = new State(newcoordinates[2], newcoordinates[3], newcoordinates[0], newcoordinates[1], 4, null, Xinit.getState().getAllCaughtCollectibles());
                            s.setSizeOfAgent(96);
                            s.point.Size = s.getSizeOfAgent();
                            s.CurrentPlatform = _domain.AllObstacles.getNextPlatform(s);
                            s.point.Size = getMaxHeight(s, Xinit.getState(), _domain)-10;
                            //Can be wrong if platform is smaller than 96
                            if (newcoordinates[2] == 0)
                                s.setPosX(s.CurrentPlatform.maxWidth() - s.getSizeOfAgent()/2); //change if you change the size from 96
                            else
                                s.setPosX(s.CurrentPlatform.minWidth() + s.getSizeOfAgent()/2); //change if you change the size from 96
                            s.setPosY(s.CurrentPlatform.maxHeight() - s.getSizeOfAgent() / 2);
                            s.point.Tilt = true;

                            this.caughtCollectible(Xinit.getState(), s); //TODO ter em conta o start diferente
                            if (Xinit._busyTiltLeft && Xinit._busyTiltRight)
                                Xinit.setActionBusy(4);
                            s.point.numberOfCollectibles = s.numberOfCollectibles();
                            if (!this.contains(s, graph)) //TODO equals ter em conta o size
                                newState = true;
                        }
                        break;
                }
            }
            RectangleNode n = new RectangleNode(s);
            return n;
		}

        private int getMaxHeight(State state, State previousState, InfoDomain domain)
        {
            int centerx;
            if (state.getVelocityX() == 0)
                centerx = (int)(state.CurrentPlatform.maxWidth() - 40 + MINSIZE/2) / 8;
            else
                centerx = (int)(state.CurrentPlatform.minWidth() - 40 - MINSIZE/2) / 8;
            int y = (int)(previousState.CurrentPlatform.maxHeight() - 40 - MAXSIZE) / 8;
            int limit = y + 12;
            int startx = centerx - MINSIZE/ 8 / 2;
            int endx = centerx + MINSIZE/ 8 / 2 - 1;

            int[,] table = domain.Table;

            for (; y < limit; y--)
            {
                for (int x = startx; x < endx; x++)
                    {
                        if (!(table[y, x] == 1 || table[y, x] == 2))
                            return (int) (previousState.CurrentPlatform.maxHeight() - (y * 8 + 40));
                    }
            }
            return 96;
        }

        private int possibleHeight(State state, InfoDomain domain)
        {
            int height = state.getSizeOfAgent();
            int width = getWidth(height);
            int centerx = (int) (state.getPosX() - 40) / 8;
            int centery = (int)(state.getPosY() - 40) / 8;
            bool thereiswall = true;
            int[,] table = domain.Table;
            float v = state.getVelocityX();
            int x;

            if (v == 0)
            {
                x = centerx - (width / 8) / 2;
                if (x < 0)
                {
                    width -= (0 - x) * 8;
                    if (width < 48)
                        return 96;
                    centerx += ((0 - x) / 2);
                    x = 0;
                }

            }  
            else
            {
                x = centerx + (width / 8) / 2 - 1;
                if (x > 149)
                {
                    width -= ((x - 149) * 8);
                    if (width < 48)
                        return 96;
                    centerx -= ((x - 149) / 2);
                    x = 149;
                }
            }

            height = getHeight(width);
               
            int starty = centery - (height / 8) / 2;
            int endy = centery + (height / 8) / 2;
            if (endy > 89)
                endy = 89;

            int iter = 1;

            while (thereiswall)
            {
                thereiswall = false;
                for (int y = starty; y < endy; y++)
                    if (table[y, x] == 1 || table[y, x] == 2)
                    {
                        thereiswall = true;
                        break;
                    }

                if (thereiswall)
                {
                    width -= 8;
                    if (width < 48)
                        return 96; //it wont pass the validator either way
                    height = getHeight(width);
                    // Y will be checked by the validator
                    if (v == 0)
                    {
                        if(iter%2 == 0)
                            centerx += 1; //half what we took from the width
                        x = centerx - (width / 8) / 2;
                    }
                    else
                    {
                        if (iter % 2 == 0)
                            centerx -= 1; //half what we took from the width
                        x = centerx + (width / 8) / 2 - 1;
                    }
                    iter++;
                        
                }
            }
            if (height < 192 - 10)
                return height + 10;
            else
                return height;
        }

        private int distanceForMomentum(State state, InfoDomain domain)
        {
            int centerx = (int) (state.getPosX() - 40) / 8;
            int centery = (int)(state.getPosY() - 40) / 8;

            int height = state.getSizeOfAgent();
            int width = getWidth(height);

            int direction = (int) state.getVelocityX();

            int startx;
            int endx;

            int starty = centery - height / 8 / 2;
            int endy = centery + height / 8 / 2;

            int[,] table = domain.Table;

            int endOfPlatform;

            if (direction == 1)
            {
                startx = centerx - width / 8 / 2;
                endOfPlatform = (int) (state.CurrentPlatform.minWidth() - 40)/8;
                endx = Math.Max(0, endOfPlatform) ;

                for (int x = startx; x >= endx; x--)
                {
                    for (int y = starty; y < endy; y++)
                    {
                        if (table[y, x] == 1 || table[y, x] == 2)
                            return (centerx - x) * 8;
                    }
                }

                return centerx * 8 - width / 2;
            }
            else
            {
                startx = centerx + width / 8 / 2 - 1;
                endOfPlatform = (int)(state.CurrentPlatform.minWidth() - 40) / 8;
                endx = Math.Min(149, endOfPlatform);

                for (int x = startx; x <= endx; x++)
                {
                    for (int y = starty; y < endy; y++)
                    {
                        if (table[y, x] == 1 || table[y, x] == 2)
                            return (x - centerx) * 8;
                    }
                }
                
                return (149 - centerx) * 8 - width / 2;
            }

        }

        public bool contains(State newState, Graph graph)
        {
            foreach (RectangleNode n in graph.getAllNodes())
            {
                if (n.getState().Equals(newState))
                    return true;
            }
            return false;
        }

        private int getWidth(int size)
        {
            return (96 * 96) / size;
        }

        private int getHeight(int width)
        {
            return (96 * 96) / width;
        }
	}
}

