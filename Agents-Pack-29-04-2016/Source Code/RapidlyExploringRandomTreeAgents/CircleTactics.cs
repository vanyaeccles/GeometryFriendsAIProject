// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------


namespace GeometryFriendsAgents
{
	public class CircleTactics : Tactics
	{
		private static float radius = 40;
		private static float min = 78;
		private static float max = 200;

		public CircleTactics ()
		{
		}

        public override RectangleNode apply(RectangleNode Xinit, InfoDomain _domain, Graph graph) { return null; }

		public override CircleNode apply (CircleNode Xinit, InfoDomain _domain, Graph graph)
		{
			bool newState = false;
			CircleActions cAction = new CircleActions();
			int action=0;
			State s=null;

			while(!newState)
			{
                if (Xinit.allActionsBusy())
                {
                    graph.NonBusyNodes.Remove(Xinit);
                    return null;
                }
				action = cAction.getRandomAction();
				switch(action)
				{
					case 0:
						if (!Xinit._busyActions[0])
						{
							float[] newcoordinates = new float[4];
							newcoordinates[0] = Xinit.getState().getPosX() - 32;
							newcoordinates[1] = Xinit.getState().getPosY();
							newcoordinates[2] = 0;  // this means going left
							newcoordinates[3] = Xinit.getState().getVelocityY();
							float[] gapInfo;
							
							s = new State(newcoordinates[2], newcoordinates[3], newcoordinates[0], newcoordinates[1], 0, null, Xinit.getState().getAllCaughtCollectibles());
							s.setSizeOfAgent(80);
							if (s.getPosX() < Xinit.getState().CurrentPlatform.minWidth())
							{
								if ((!Xinit.getState().SpecialMoveL) && ((gapInfo = _domain.AllObstacles.isThereAGap(s, Xinit.getState().CurrentPlatform, min, max)) != null))
								{
									s.setPosX(s.getPosX() - gapInfo[0] - s.getSizeOfAgent() / 2);
									s.point.x = s.getPosX();
									s.CurrentPlatform = _domain.AllObstacles.getNextPlatform(s);
									s.point.Platform = s.CurrentPlatform;
									s.point.y = s.getPosY();
									Xinit.getState().SpecialMoveL = true;
									s.point.Gap = true;
								}
								else
								{
									s.CurrentPlatform = _domain.AllObstacles.getNextPlatformRange(s, 100);
									s.point.Platform = s.CurrentPlatform;
									s.setPosY(s.CurrentPlatform.maxHeight() - radius);
									s.point.Fall = true;
									s.point.x = Xinit.getState().CurrentPlatform.minWidth() - radius;
									s.point.y = s.getPosY();
									s.setPosX(s.point.x);
									Xinit.setActionBusy(0);
								}
							}
							else
							{
								Xinit.setActionBusy(0);
								s.CurrentPlatform = Xinit.getState().CurrentPlatform;
								s.point.Platform = s.CurrentPlatform;
							}

                            this.caughtCollectible(Xinit.getState(), s);
                            s.point.numberOfCollectibles = s.numberOfCollectibles();
							if (!this.contains(s, graph))
								newState = true;
						}
						break;
					case 1:
						if (!Xinit._busyActions[1])
						{
							float[] newcoordinates = new float[4];
							newcoordinates[0] = Xinit.getState().getPosX() + 32;
							newcoordinates[1] = Xinit.getState().getPosY();
							newcoordinates[2] = 1;  // this means going right
							newcoordinates[3] = Xinit.getState().getVelocityY();
							float[] gapInfo;

							s = new State(newcoordinates[2], newcoordinates[3], newcoordinates[0], newcoordinates[1], 1, null, Xinit.getState().getAllCaughtCollectibles());
							s.setSizeOfAgent(80);

							if (s.getPosX() > Xinit.getState().CurrentPlatform.maxWidth())
							{
								if ((!Xinit.getState().SpecialMoveR) && ((gapInfo = _domain.AllObstacles.isThereAGap(s, Xinit.getState().CurrentPlatform, min, max)) != null))
								{
									s.setPosX(s.getPosX() + gapInfo[0] + s.getSizeOfAgent() / 2);
									s.point.x = s.getPosX();
									s.CurrentPlatform = _domain.AllObstacles.getNextPlatform(s);
									s.point.Platform = s.CurrentPlatform;
									s.point.y = s.getPosY();
									Xinit.getState().SpecialMoveR = true;
									s.point.Gap = true;
								}
								else
								{
									s.CurrentPlatform = _domain.AllObstacles.getNextPlatform(s);
									s.point.Platform = s.CurrentPlatform;
									s.setPosY(s.CurrentPlatform.maxHeight() - radius);
									s.point.Fall = true;
									s.point.x = Xinit.getState().CurrentPlatform.maxWidth() + radius;
									s.setPosX(s.point.x); 
									s.point.y = s.getPosY();
									Xinit.setActionBusy(1);
								}
							}
							else
							{
								Xinit.setActionBusy(1);
								s.CurrentPlatform = Xinit.getState().CurrentPlatform;
								s.point.Platform = s.CurrentPlatform;
							}

                            this.caughtCollectible(Xinit.getState(), s);
                            s.point.numberOfCollectibles = s.numberOfCollectibles();
							if (!this.contains(s, graph))
								newState = true;
							}
						break;
					case 2:
						if (!Xinit._busyActions[2])
						{
							float[] newcoordinates = new float[4];
							newcoordinates[0] = Xinit.getState().getPosX();
							newcoordinates[1] = Xinit.getState().getPosY()-305;
							newcoordinates[2] = Xinit.getState().getVelocityX();
							newcoordinates[3] = Xinit.getState().getVelocityY();
							
							s = new State(newcoordinates[2], newcoordinates[3], newcoordinates[0], newcoordinates[1], 2, null, Xinit.getState().getAllCaughtCollectibles());
							s.setSizeOfAgent(80);

							Xinit.setActionBusy(2);
							s.CurrentPlatform = Xinit.getState().CurrentPlatform;
							s.point.Platform = s.CurrentPlatform;
							
							this.caughtCollectible(Xinit.getState(), s);
							s.setPosY(s.getPosY()+305);

							if (Xinit.getState().sizeOfCaughtCollectible() < s.sizeOfCaughtCollectible())
							{
								s.point.DiamondAbove = true;
								if (Xinit.getState().getAction() == 0)
								{
									s.point.x -= 32;
									s.point.x -= radius;
								}
								else if (Xinit.getState().getAction() == 1)
								{
									s.point.x += 32;
									s.point.x += radius;
								}

							}else
                            { continue; }

                            s.point.y = s.getPosY();
                            s.point.numberOfCollectibles = s.numberOfCollectibles();
							if (!this.contains(s, graph))
								newState = true;
							
						}
						break;
				case 3:
					if(!Xinit._busyActions[3])
					{
						float[] newcoordinates = new float[4];
						newcoordinates[0] = Xinit.getState().getPosX();
						newcoordinates[1] = Xinit.getState().getPosY() - 305;
						newcoordinates[2] = Xinit.getState().getVelocityX();
						newcoordinates[3] = Xinit.getState().getVelocityY();

                        //if(newcoordinates[2] == 0) // going left
                        //    newcoordinates[0] -= 64;
                        //else if(newcoordinates[2] == 1)	// going right
                        //    newcoordinates[0] += 64;

                        if (newcoordinates[2] == 0) // going left
                            newcoordinates[0] -= 384;
                        else if (newcoordinates[2] == 1)	// going right
                            newcoordinates[0] += 384;

						s = new State(newcoordinates[2], newcoordinates[3],newcoordinates[0], newcoordinates[1], 3, null, Xinit.getState().getAllCaughtCollectibles());
						s.setSizeOfAgent(80);
						s.CurrentPlatform = Xinit.getState().CurrentPlatform;

						if(s.ReachableObstacles == null)
						{
							if( s.VisitedPlatforms == null)
							{
								s.ReachableObstacles = _domain.AllObstacles.platformsAbove(Xinit.getState(), s);
								s.VisitedPlatforms = new bool[s.ReachableObstacles.Count];
							}
							else
							{
								Xinit.setActionBusy(3);
								return null;
							}
						}
						if(s.ReachableObstacles != null)
						{
							Obstacles.Obstacle o = null;
							int i=0;
							for(i = 0; i < s.ReachableObstacles.Count ; i++)
							{
								if( !s.VisitedPlatforms[i] )
								{
									o = (Obstacles.Obstacle)s.ReachableObstacles[i];
									break;
								}
							}

							if ( o == null )
							{
								Xinit.setActionBusy(3);
								return null;
							}
							else
							{
								if( s.getVelocityX() == 0) // going left
								{
									s.setPosX(o.maxWidth() - s.getSizeOfAgent()/2);
								}
								else if ( s.getVelocityX() == 1 ) // going right
								{
									s.setPosX(o.minWidth() + s.getSizeOfAgent()/2);
								}
								
								s.setPosY(o.maxHeight() - s.getSizeOfAgent()/2);
								s.point.x = s.getPosX();
								s.point.y = s.getPosY();
								s.point.ToPlatform = true;
								s.CurrentPlatform = o;
								s.point.Platform = s.CurrentPlatform;
								s.VisitedPlatforms[i] = true;
								Xinit.setActionBusy(3);
							}
						}
						else
						{
							return null;
						}

                        this.caughtCollectible(Xinit.getState(), s);
                        s.point.numberOfCollectibles = s.numberOfCollectibles();

						if(!this.contains(s, graph))
							newState = true;
					}
					break;
				}
			}
			CircleNode n = new CircleNode(s);
			return n;
		}

        private int distanceForMomentum(State state, InfoDomain domain)
        {
            int centerx = (int)(state.getPosX() - 40) / 8;
            int centery = (int)(state.getPosY() - 40) / 8;

            int size = 80;

            int direction = (int)state.getVelocityX();

            int startx;
            int endx;

            int starty = centery - size / 8 / 2;
            int endy = centery + size / 8 / 2;

            int[,] table = domain.Table;

            if (direction == 1)
            {
                startx = centerx - size / 8 / 2;
                endx = 0;

                for (int x = startx; x >= endx; x--)
                {
                    for (int y = starty; y < endy; y++)
                    {
                        if (table[y, x] == 1 || table[y, x] == 3)
                            return (centerx - x) * 8;
                    }
                }

                return centerx * 8 - size / 2;
            }
            else
            {
                startx = centerx + size / 8 / 2 - 1;
                endx = 149;

                for (int x = startx; x <= endx; x++)
                {
                    for (int y = starty; y < endy; y++)
                    {
                        if (table[y, x] == 1 || table[y, x] == 3)
                            return (x - centerx) * 8;
                    }
                }

                return (149 - centerx) * 8 - size / 2;
            }

        }

		public bool contains(State newState, Graph graph)
		{
			foreach(CircleNode n in graph.getAllNodes())
			{
				if (n.getState().Equals(newState))
					return true;
			}
			return false;
		}
	}
}

